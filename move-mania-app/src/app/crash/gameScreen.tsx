"use client";

import crypto from "crypto";
import { useContext, useEffect, useState } from "react";
import { GameStatus } from "./controlCenter";
import { SOCKET_EVENTS, RoundStart } from "@/lib/types";
import { Socket, io } from "socket.io-client";
import CountUp from "react-countup";
import { getCurrentGame } from "@/lib/api";
import { startRound } from "@/lib/socket";

import { socket } from "@/lib/socket";

import { gameStatusContext } from "./CrashProvider";
import CrashChart from "@/components/CrashChart.client";
import CandlestickChart from "@/components/CandlestickChart.client";
import { UTCTimestamp } from "lightweight-charts";

export default function GameScreen() {
  const {
    gameStatus,
  } = useContext(gameStatusContext);
  const [update, setUpdate] = useState(true);

  const onStartRound = () => {
    if (!socket) return;

    const success = startRound();
  };

  if (gameStatus === null) {
    return (
      <div className="border-b border-l border-green-500 h-full w-full bg-neutral-950">
        <span onClick={onStartRound}>No games yet - click here to admin start one</span>
      </div>
    );
  } else if (gameStatus.status === "COUNTDOWN") {
    return (
      <div className="border-b border-l border-green-500 h-full w-full bg-neutral-950">
        <CountUp
          start={(gameStatus.startTime! - Date.now()) / 1000}
          end={0}
          duration={(gameStatus.startTime! - Date.now()) / 1000}
          separator=" "
          decimals={0}
          decimal="."
          prefix="Game starts in "
          suffix=" seconds"
          useEasing={false}
        />
        <CandlestickChart startTime={gameStatus.startTime!} crashPoint={gameStatus.crashPoint} data={generateChartData(gameStatus.roundId)} />
      </div>
    );
  } else if (gameStatus.status === "IN_PROGRESS") {
    const hardcodedCrashPoint = 5000;
    console.log("Current gameStatus:", gameStatus);
    return (
      <div className="border-b border-l border-green-500 h-full w-full bg-neutral-950">
        <CountUp
          start={(Date.now() - gameStatus.startTime!) / 1000}
          end={gameStatus.crashPoint!}
          duration={gameStatus.crashPoint!}
          separator=""
          decimals={2}
          decimal="."
          prefix=""
          suffix="x"
          useEasing={false}
        />
        <CandlestickChart startTime={gameStatus.startTime!} crashPoint={gameStatus.crashPoint} data={generateChartData(gameStatus.roundId)} />
      </div>
    );
  } else if (gameStatus.status === "END") {
    return (
      <div className="border-b border-l border-green-500 h-full w-full bg-neutral-950">
        <div>
          <CountUp
            start={gameStatus.crashPoint!}
            end={gameStatus.crashPoint!}
            duration={0}
            separator=""
            decimals={2}
            decimal="."
            prefix=""
            suffix="x"
            useEasing={false}
          />
          <CandlestickChart startTime={gameStatus.startTime!} crashPoint={gameStatus.crashPoint} data={generateChartData(gameStatus.roundId)} />
        </div>
      </div>
    );
  }
}

/**
 * 
 * @param gameRoundId The id of the current game round
 * 
 * @returns A list of data points for the candlestick chart
 * 
 * @description This function generates the data points for the candlestick chart. It uses the 
 * gameRoundId to generate a hash. The hash string is then iterated over to generate the data points.
 * Each character in the hash string is used to generate a data point. The data point is generated by
 * taking the character's HEX value and using it to generate the open, high, low, and close values.
 * Every character between 1 and 4 are negative, and the rest are positive. The open value is the
 * close value of the previous data point. The close value is the open value plus the character's HEX
 * value. The high and low values are the open and close values plus or minus a random number between
 * 0 and 0.2. The random number should be generated with the hex character as the seed. The time value
 * should increase by 1 second for each data point. The time value should be a string in the format
 * "YYYY-MM-DDTHH:MM:SSZ". The data points should be generated until the length of the hash string is
 * reached. The data points should be returned as an array of objects.
 */
function generateChartData(gameRoundId: string) {
  const hasher = crypto.createHash("sha256");

  if (hasher === undefined) {
    console.log("Hasher is undefined")
    return [];
  }

  console.log("gameRoundId:", gameRoundId)

  const gameRoundHash = hasher.update(gameRoundId).digest("hex");
  console.log("gameRoundHash:", gameRoundHash);

  const dataPoints = [];
  let currentDate = new Date("2021-01-01T00:00:00Z");

  for (let i = 0; i < gameRoundHash.length; i++) {
    const hexChar = gameRoundHash[i];
    const hexValue = parseInt(hexChar, 16);
    const open: number = i === 0 ? 50 : dataPoints[i - 1].close;
    const close = open + hexValue;
    const high = close + Math.random() * 0.2;
    const low = open - Math.random() * 0.2;
    const timeString = currentDate.toISOString().split("T")[0];
    dataPoints.push({ time: timeString as unknown as UTCTimestamp, open, high, low, close });
    currentDate = new Date(currentDate.getTime() + 1000);
  }

  return dataPoints;
}